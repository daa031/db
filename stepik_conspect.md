<br><a name="T-1"></a>

[**_`CREATE TABLE <имя таблицы> (<имя столбца 1> <тип>, <имя столбца 2> <тип>) VALUES(<первая строка>),(<вторая строка>);`_**](#T1)<br> - запрос на создание таблицы (типы INT PRIMARY KEY AUTO*INCREMENT,VARCHAR(<кол-во символов>), INT, DECIMAL(<максимальное кол-во цифр>,<кол-во цифр после запятой>))
Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос SELECT, результирующая таблица которого и будет новой таблицей базы данных. ` CREATE TABLE имя*таблицы AS SELECT ... `

---

[**_`SELECT <(all)>, <имя столбца1>, <имя столбца2> FROM <имя таблицы>`_**](#T2)<br> - запрос на выборку с таблицы

---

[**_`ROUND(x, k) | ABS(x) | SQRT(x)	| CEILING(x)`_**](#T3)<br> - математические функции

---

[**_`IF(логическое выражение, выражение_1, выражение_2)`_**](#T4)<br> - условный оператор вернет в1 или в2

---

[**_`WHERE`_**](#T5)<br>- Выборка данных по условию

---

[**_`BETWEEN` | `IN`_**](#T6)<br> - between позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.
**пример**:` WHERE <имя столбца> BETWEEN 5 AND 14;`

---

[**_`ORDER BY`_**](#T7)<br> - сортировка (`ASC`- по возрастанию | `DESC`- по убыванию) пример:`ORDER BY author, amount DESC; `

---

[**_`LIKE`_**](#T8)<br> - отобрать строку
`%` - Любая строка, содержащая ноль или более символов |
`*` - Любой одиночный символ

---

[**_`DISTINCT`_**](#T9)<br> - выбор уникальных элементов столбца - аналог GROUP BY пример: `SELECT DISTINCT author FROM book; `

---

[**_`SUM и COUNT`_**](#T10)<br> - групповые функции
пример: `count(title) as Различных_книг, sum(amount) as Количество_экземпляров`

---

[**_`MIN()`, `MAX()` , `AVG()`_**](#T11)<br> - групповые функции - вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

---

[**_`ROUND()`_**](#T12)<br> - среднее значение по столбцу

---

[**_`HAVING`_**](#T13)<br> - В запросах с групповыми функциями размещается после оператора `GROUP BY`
пример: `... GROUP BY author HAVING SUM(price _ amount) > 5000`

---

[**_`WHERE`_**](#T14)<br> - Вложенный запрос | пример: `WHERE price = (SELECT MIN(price) FROM book )`

---

[**_`IN`_**](#T15)<br>- во вложенном запросе`WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец`

---

[**_`ANY()` | `ALL ()`_**](#T16)<br> - во вложенном запросе |`ANY`будут включены все записи, для которых выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. | `ALL`в результирующую таблицу будут включены все записи, для которых выражение со знаком отношения верно для всех элементов результирующего запроса.

---

[**_`UPDATE`_**](#T17)<br> - Запросы на обновление (`UPDATE таблица SET поле = выражение, поле2 = выражение2,`)

или запрос на обновление нескольких таблиц:

```sql
update book, supply
set book.amount = book.amount + supply.amount,
    book.price = round((book.price+supply.price)/2, 2)
where book.title = supply.title
```

---

[**_`DELETE`_**](#T18)<br> - Запрос на удаление | `DELETE FROM таблица WHERE .... IN ();`

---

[**_`DELETLIMIT <кол-во строк>E`_**](#T19)<br> - Для ограничения вывода записей. Размещается после раздела `ORDER BY`.

---

[**_`про даты`_**](#T20)<br>

`DATEDIFF(дата_1, дата_2)` - результатат - количество дней между дата_1 и дата_2

`MONTH(<дата>)` - Выделить номер месяца из даты

`MONTHNAME(<дата>)` - Выделить название месяца на английском из даты

`DAY('2020-02-01') = 1` || `MONTH('2020-02-01') = 2` || `YEAR('2020-02-01') = 2020` - выделить часть даты

---

[**_`Использование временного имени таблицы (алиаса)`_**](#T21)<br>

`FROM fine AS f, traffic_violation AS tv ` или `FROM fine f, traffic_violation tv` - Использование временного имени таблицы (алиаса)
После присвоения таблице алиаса, он используется во всех разделах запроса, в котором алиас задан. `WHERE f.violation = tv.violation`

---

[**_`group by ст1, ст2, ст3`_**](#T22)<br> - Группировка данных по нескольким столбцам

---

[**_`having count(*) > 1`_**](#T23)<br> - счетчик

---

**_сводка по всем операторам_**

# 1.1 отношения

верная последовательность команд:

```sql
SELECT 'столбцы или * для выбора всех столбцов; обязательно'

FROM 'таблица; обязательно'

WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно'

GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно'

HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно'

ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно'
```

![прмиер отошения](/images/table.jpg)

> - отношение – это структура данных целиком, набор записей (в обычном понимании – таблица) , в примере –это Сотрудник;
> - кортеж – это каждая строка , содержащая данные (более распространенный термин – запись ), например, <001, Борин С.А, 234-01-23, программист>, все кортежи в отношении должны быть различны;
> - мощность – число кортежей в таблице (проще говоря, число записей), в данном случае 3, мощность отношения может быть любой (от 0 до бесконечности), порядок следования кортежей - неважен;
> - атрибут – это столбец в таблице (более распространенный термин – поле ), в примере – Табельный номер, Фамилия И.О., Телефон, Должность)
> - размерность – это число атрибутов в таблице, в данном случае – 4; размерность отношения должна быть больше 0, порядок следования атрибутов существенен;
> - домен атрибута – это допустимые значения (неповторяющиеся), которые можно занести в поле , например для атрибута Должность домен – {инженер, программист}.

<br><a name="T1"></a>

пример запроса на создание таблицы:

```sql
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(25),
    author VARCHAR(30),
    price DECIMAL(8,2),
    amount INT
);
```

прмиер вставки в таблицу:

```sql
INSERT book (title, author, price, amount)
    VALUES ('Мастер и Маргарита', 'Булгаков М.А.', 670.99	, 3);
```

или :

```sql
INSERT book (title, author, price, amount)
VALUES ('Белая гвардия', 'Булгаков М.А.', 540.50, 5),
        ('Идиот',	'Достоевский Ф.М.', 	460.00, 10),
        ('Братья Карамазовы', 'Достоевский Ф.М.',799.01,	2 );
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T2"></a>

# 1.2 выборка данных

пример тобрать все данные из таблицы:

```sql
SELECT * FROM book;
```

прмиер Выбрать названия книг и их количества из таблицы book :

```sql
SELECT title, amount FROM book;
```

прмиер выбрать из таблицы с изменением названия столбцов

```sql
SELECT
    title AS Название,
    author AS Автор
FROM book;
```

пример Выборка данных с созданием вычисляемого столбца:

```sql
SELECT title,
    amount,
    amount * 1.65 AS pack
FROM book
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T3"></a>

**_математические функции_**:
| Функция | Описание | Пример |
|------ | ------- | ------|
|`CEILING(x)`| возвращает наименьшее целое число, большее или равное x (округляет до целого числа в большую сторону)|EILING(4.2)=5 CEILING(-5.8)=-5|
`ROUND(x, k)`|округляет значение **x** до **k** знаков после запятой, если **k** не указано – **x** округляется до целого|ROUND(4.361)=4 ROUND(5.86592,1)=5.9|
|`FLOOR(x)`|возвращает наибольшее целое число, меньшее или равное x (округляет до целого числа в меньшую сторону)| FLOOR(4.2)=4 FLOOR(-5.8)=-6|
|`POWER(x, y)`| возведение **x** в степень **y**|POWER(3,4)=81.0|
|`SQRT(x)` | квадратный корень из **x** | SQRT(4)=2.0 SQRT(2)=1.41...|
|`DEGREES(x)`|конвертирует значение **x** из радиан в градусы| DEGREES(3) = 171.8...|
|`RADIANS(x)`|конвертирует значение x из градусов в радианы|RADIANS(180)=3.14...|
|`ABS(x)`| модуль числа x| ABS(-1) = 1 ABS(1) = 1|
|`PI()`|pi = 3.1415926...|

пример использования округления:

```sql
SELECT title,
    price,
    ROUND((price*18/100)/(1+18/100),2) AS tax,
    ROUND(price/(1+18/100),2) AS price_tax
FROM book;
```

[**_НАЗАД_**](#T-1)</a>

## Выборка данных, вычисляемые столбцы, логические функции

<br><a name="T4"></a>

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция IF

`IF(логическое_выражение, выражение_1, выражение_2)`

пример запроса:

```sql
SELECT title, amount, price,
    IF(amount<4, price*0.5, price*0.7) AS sale
FROM book;
```

прмиер вложенного IF запроса:

```sql
SELECT title, amount, price,
    ROUND(IF(amount < 4, price * 0.5, IF(amount < 11, price * 0.7, price * 0.9)), 2) AS sale,
    IF(amount < 4, 'скидка 50%', IF(amount < 11, 'скидка 30%', 'скидка 10%')) AS Ваша_скидка
FROM book;
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T5"></a>

## Выборка данных по условию

пример:

```sql
SELECT title, author, price * amount AS total
FROM book
WHERE price * amount > 4000;
```

## Выборка данных, логические операции

Приоритеты операций:

1. круглые скобки
2. умножение (\*), деление (/)
3. сложение (+), вычитание (-)
4. операторы сравнения (=, >, <, >=, <=, <>)
5. NOT
6. AND
7. OR

пример:

```SQL
SELECT title, author, price
FROM book
WHERE (author = 'Булгаков М.А.' OR author = 'Есенин С.А.') AND price > 600;
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T6"></a>

## операторы BETWEEN, IN

Логическое выражение после ключевого слова `WHERE` может включать операторы `BETWEEN` и `IN`.
Оператор `BETWEEN` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

пример:

```sql
SELECT title, amount
FROM book
WHERE amount BETWEEN 5 AND 14;
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T7"></a>

## Сортировка | `ORDER BY`

По умолчанию `ORDER BY` выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово `ASC` (по возрастанию) или `DESC` (по убыванию).

пример:

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, amount DESC;
```

или другие варианты

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, Количество DESC;
```

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY 1, 3 DESC;
```

`Важно`! Если названия столбцов заключены в кавычки, то при использовании их в сортировке, необходимо записывать их БЕЗ КАВЫЧЕК.

[**_НАЗАД_**](#T-1)</a>

<br><a name="T8"></a>

## Оператор LIKE

Оператор `LIKE` используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), `LIKE` позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать **обычные символы** и **символы-шаблоны**.

| Символ-шаблон | Описание                                         | Пример                                                                                                                                |
| ------------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| %             | Любая строка, содержащая ноль или более символов | `SELECT * FROM book WHERE author LIKE '%М.%'` выполняет поиск и выдает все книги, инициалы авторов которых содержат _«М.»_            |
| \_            | Любой одиночный символ                           | `SELECT * FROM book WHERE title LIKE 'Поэм_'` выполняет поиск и выдает все книги, названия которых либо «Поэма», либо _«Поэмы»_ и пр. |

Вывести названия книг, начинающихся с буквы «Б».

```sql
SELECT title
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие
title LIKE 'б%'
*
```

пример Вывести название книг, состоящих ровно из 5 букв:

```sql
SELECT title FROM book
WHERE title LIKE "_____"
```

пример Вывести книги, название которых длиннее 5 символов:

```sql
SELECT title FROM book
WHERE title LIKE "______%";
/* эквивалентные условия
title LIKE "%______"
title LIKE "%______%"
*/
```

пример:

```sql
SELECT title FROM book
WHERE   title LIKE "_% и _%" /*отбирает слово И внутри названия */
    OR title LIKE "и _%" /*отбирает слово И в начале названия */
    OR title LIKE "_% и" /*отбирает слово И в конце названия */
    OR title LIKE "и" /* отбирает название, состоящее из одного слова И */
```

[**_НАЗАД_**](#T-1)</a>

# 1.3 Запросы, групповые операции

<br><a name="T9"></a>

## Выбор уникальных элементов столбца

Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово DISTINCT, которое размещается сразу после SELECT.
Пример Выбрать различных авторов, книги которых хранятся в таблице book:

```sql
SELECT DISTINCT author
FROM book;
```

Другой способ – использование оператора GROUP BY, который группирует данные при выборке, имеющие одинаковые значения в некотором столбце.

пример:

```sql
SELECT  author
FROM book
GROUP BY author;
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T10"></a>

## групповые функции SUM и COUNT

пример:

```sql
select
    author as  Автор,
    count(title) as Различных_книг,
    sum(amount) as Количество_экземпляров
from book
group by author;
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T11"></a>

## групповые функции MIN, MAX и AVG

`MIN()`, `MAX()` и `AVG()`, вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

Пример:

```SQL
select
    author,
    min(price) as Минимальная_цена,
    max(price) as Максимальная_цена,
    avg(price) as Средняя_цена
from book
group by author;
```

[**_НАЗАД_**](#T-1)</a>

## Выборка данных c вычислением, групповые функции

<br><a name="T12"></a>

Пример Найти среднюю цену книг каждого автора.

```sql
SELECT author, ROUND(AVG(price),2) AS Средняя_цена
FROM book
GROUP BY author;
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T13"></a>

## Выборка данных по условию, групповые функции

В запросы с групповыми функциями можно включать условие отбора строк, записывается после `WHERE`. В запросах с групповыми функциями вместо `WHERE` используется ключевое слово `HAVING` , которое размещается после оператора `GROUP BY`.

пример:

```SQL
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000
ORDER BY Минимальная_цена DESC;
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T14"></a>

## Выборка данных по условию, групповые функции, WHERE и HAVING

`WHERE` и `HAVING` могут использоваться в одном запросе. При этом необходимо учитывать **порядок выполнения SQL запроса на выборку на СЕРВЕРЕ:**

1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

Сначала определяется таблица, из которой выбираются данные `FROM`, затем из этой таблицы отбираются записи в соответствии с условием `WHERE`, выбранные данные агрегируются `GROUP BY`, из агрегированных записей выбираются те, которые удовлетворяют условию после `HAVING`. Потом формируются данные результирующей выборки, как это указано после `SELECT` ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется, как указано после `ORDER BY`.

Пример Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10:

```sql
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
```

или решать так:

```sql
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
```

# 1.4 Вложенные запросы

> Вложенные запросы могут включаться в WHERE или HAVING так
>
> - `WHERE | HAVING` выражение оператор_сравнения (вложенный запрос);
> - `WHERE | HAVING` выражение, включающее вложенный запрос;
> - `WHERE | HAVING` выражение [NOT] IN (вложенный запрос);
> - `WHERE | HAVING` выражение оператор_сравнения ANY | ALL (вложенный запрос)

пример Вывести информацию о самых дешевых книгах, хранящихся на складе :

```sql
SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price)
         FROM book
      )
```

### Использование вложенного запроса в выражении

пример Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3. То есть нужно вывести и те книги, количество экземпляров которых меньше среднего на 3, или больше среднего на 3:

```sql
SELECT title, author, amount
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
```

пример Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде:

```sql
select
    author,
    title,
    price
from book
where price - (select min(price) from book) <= 150
order by price
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T15"></a>

### Вложенный запрос, оператор IN

Вложенный запрос может возвращать несколько значений одного столбца. Тогда его можно использовать в разделе WHERE совместно с оператором IN.
`WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)`

пример Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не дублируется:

```sql
select
    author,
    title,
    amount
from book
where amount in (
        select
            amount
        from book
        group by amount
        having count(amount) = 1
    );
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T16"></a>

### Вложенный запрос, операторы ANY и ALL

Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов `ANY` и `ALL` совместно с операциями отношения (=, <>, <=, >=, <, >).

Операторы `ANY` и `ALL` используются в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.

При использовании оператора `ANY` в результирующую таблицу будут включены все записи, для которых выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Оператор `ANY`:

- `amount > ANY (10, 12)` эквивалентно amount > 10

- `amount < ANY (10, 12)` эквивалентно amount < 12

- `amount = ANY (10, 12`) эквивалентно (amount = 10) OR (amount = 12), а также amount IN (10,12)

- `amount <> ANY (10, 12)` вернет все записи с любым значением amount, включая 10 и 12

При использовании оператора `ALL` в результирующую таблицу будут включены все записи, для которых выражение со знаком отношения верно для всех элементов результирующего запроса. Оператор `ALL`:

- `amount > ALL (10, 12)` эквивалентно amount > 12

- `amount < ALL (10, 12)` эквивалентно amount < 10

- `amount = ALL (10, 12)` не вернет ни одной записи, так как эквивалентно (amount = 10) AND (amount = 12)
- `amount <> ALL (10, 12)` вернет все записи кроме тех, в которыхamount равно 10 или 12

> **Важно!** Операторы `ALL` и `ANY` можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса. В запросах так записывать нельзя.

пример Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора. :

```sql
select
    author,
    title,
    price
from book
where price < any (
    select
       min(price) as min_price
    from book
    group by author
    )
```

### Вложенный запрос после SELECT

Вложенный запрос может располагаться после ключевого слова `SELECT`. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.

пример Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе. Вывести название книги, ее автора, текущее количество экземпляров на складе и количество заказываемых экземпляров книг. Последнему столбцу присвоить имя Заказ. В результат не включать книги, которые заказывать не нужно.:

```sql
select
    title,
    author,
    amount,
    ((select max(amount)  from book ) - amount) as Заказ
from book
where ((select max(amount)  from book ) - amount) > 0
```

пример Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3, а также указать среднее значение количества экземпляров книг.:

```sql
SELECT title, author, amount,
    (
     SELECT AVG(amount)
     FROM book
    ) AS Среднее_количество
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
```

пояснение
Во вложенном запросе вычисляется среднее количество экземпляров книг на складе. Этот запрос используется и в условии отбора, и для создания столбца Среднее_количество в результирующей таблице запроса. Значения столбца одинаковы во всех строках, поскольку вложенный запрос возвращает одно значение.

Среднее количество в виде дробного числа выглядит не очень правильно. Полученное значение можно округлить "вниз" - до ближайшего меньшего целого.
[**_НАЗАД_**](#T-1)</a>

# 1.5 Запросы корректировки данных

### Добавление записей из другой таблицы

пример:

```sql
INSERT INTO book (title, author, price, amount)
SELECT title, author, price, amount
FROM supply;
```

пример Занести из таблицы supply в таблицу book только те книги, названия которых отсутствуют в таблице book:

```sql
INSERT INTO book (title, author, price, amount)
SELECT title, author, price, amount
FROM supply
WHERE title NOT IN (
        SELECT title
        FROM book
      );
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T17"></a>

### Запросы на обновление

Обновлением данных - изменение значений в существующих записях таблицы. Возможно как изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки.

Изменение записей в таблице реализуется с помощью запроса `UPDATE`.

```SQL
UPDATE таблица SET поле = выражение
```

Пример УУменьшить на 30% цену тех книг в таблице book, количество которых меньше 5:

```sql
UPDATE book
SET price = 0.7 * price
WHERE amount < 5;
```

Пример: В таблице book необходимо скорректировать значение для покупателя в столбце buy таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце amount. А цену тех книг, которые покупатель не заказывал, снизить на 10%:

```sql
update book
set price = if (buy = 0, price * 0.9, price),
    buy = if (buy > amount, amount, buy)
```

### Запросы на обновление нескольких таблиц

- для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, `book.price` – столбец `price` из таблицы `book`, `supply.price` – столбец `price` из таблицы `supply`;
- все таблицы, используемые в запросе, нужно перечислить после ключевого слова `UPDATE`;
- в запросе обязательно условие `WHERE`, в котором указывается условие при котором обновляются данные.

Пример Для тех книг в таблице book , которые есть в таблице supply, не только увеличить их количество в таблице book ( увеличить их количество на значение столбца amountтаблицы supply), но и пересчитать их цену (для каждой книги найти сумму цен из таблиц book и supply и разделить на 2):

```sql
update book, supply
set book.amount = book.amount + supply.amount,
    book.price = round((book.price+supply.price)/2, 2)
where book.title = supply.title
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T18"></a>

### Запросы на удаление

Этот запрос удаляет все записи из указанной после FROM таблицы.

```sql
DELETE FROM таблица;
```

пример Удалить из таблицы supply книги тех авторов, общее количество экземпляров книг которых в таблице book превышает 10:

```sql
delete from supply
where author in (
    select author
    from book
    group by author
    HAVING sum(amount) >= 10
)
```

### Запросы на создание таблицы

Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос SELECT, результирующая таблица которого и будет новой таблицей базы данных.

```sql
CREATE TABLE имя_таблицы AS
SELECT ...
```

пример Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше среднего количества экземпляров книг в таблице book. В таблицу включить столбец amount, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book:

```sql
CREATE TABLE ordering AS
       SELECT author,
              title,
              (SELECT round(AVG(amount)) FROM book) AS amount
               FROM book
               WHERE amount < (SELECT round(AVG(amount)) FROM book
               );

SELECT * FROM ordering;
```

# 1.6 Таблица "Командировки", запросы на выборку

### тут в основном задания

пример: Для каждого города посчитать, сколько раз сотрудники в нем были. Информацию вывести в отсортированном в алфавитном порядке по названию городов. Вычисляемый столбец назвать Количество:

```sql
select
    city,
    count(name) as Количество
from trip
group by city
order by city
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T19"></a>

### Оператор LIMIT

Для ограничения вывода записей в SQL используется оператор `LIMIT` , после которого указывается количество строк. Результирующая таблица будет иметь количество строк не более указанного после `LIMIT`. `LIMIT` размещается после раздела `ORDER BY`.

пример Вывести два города, в которых чаще всего были в командировках сотрудники. Вычисляемый столбец назвать Количество:

```sql
select distinct
    city,
    count(name) as Количество
from trip
group by  city
order by count(name) desc
limit 2
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T20"></a>

### Функция DATEDIFF

Для вычитания двух дат используется функция `DATEDIFF(дата_1, дата_2)`, результатом которой является количество дней между **дата_1** и **дата_2**.

```SQL
DATEDIFF('2020-05-09','2020-05-01')=8
```

пример

```sql
select
    name,
    city,
    datediff(date_last,date_first ) + 1 as Длительность
from trip
where city <>'Москва' and city <> 'Санкт-Петербург'
order by datediff(date_first,date_last), city desc
```

пример Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени. В результат включить столбцы name, city, date_first, date_last:

```sql
select
    name,
    city,
    date_first,
    date_last
from trip
where DATEDIFF(date_last, date_first) = (
    select
    min(DATEDIFF(date_last, date_first))
    from trip
    )
```

### Функция MONTH

Для того, чтобы выделить номер месяца из даты используется функция `MONTH(дата)`.

```sql
MONTH('2020-04-12') = 4
```

### Функция MONTHNAME

Для того, чтобы выделить название месяца из даты используется функция `MONTHNAME(дата)`, которая возвращает название месяца на английском языке для указанной даты.

```
MONTHNAME('2020-04-12')='April'.
```

пример:

```sql
select
    MONTHNAME(date_first) as Месяц,
    count(name) as Количество
from trip
group by MONTHNAME(date_first)
order by Количество desc, Месяц
```

### В SQL есть функции, которые позволяют выделить часть даты: день(DAY()), месяц (MONTH()), год(YEAR()) . Например:

```sql
DAY('2020-02-01') = 1
MONTH('2020-02-01') = 2
YEAR('2020-02-01') = 2020
```

[**_НАЗАД_**](#T-1)</a>

# 1.7 запросы корректировки

<br><a name="T21"></a>

### Использование временного имени таблицы (алиаса)

- с использованием ключевого слова `AS`

```SQL
FROM fine AS f, traffic_violation AS tv
```

- и без него

```SQL
FROM fine f, traffic_violation tv
```

После присвоения таблице алиаса, он используется во всех разделах запроса, в котором алиас задан.

```sql
WHERE f.violation = tv.violation
```

пример Для тех, кто уже оплатил штраф, вывести информацию о том, изменялась ли стандартная сумма штрафа:

```sql
SELECT  f.name, f.number_plate, f.violation,
   if(
    f.sum_fine = tv.sum_fine, "Стандартная сумма штрафа",
    if(
      f.sum_fine < tv.sum_fine, "Уменьшенная сумма штрафа", "Увеличенная сумма штрафа"
    )
  ) AS description
FROM  fine f, traffic_violation tv
WHERE tv.violation = f.violation and f.sum_fine IS NOT Null;
```

[**_НАЗАД_**](#T-1)</a>

<br><a name="T22"></a>

### Группировка данных по нескольким столбцам

В разделе GROUP BY можно указывать несколько столбцов, разделяя их запятыми. Тогда к одной группе будут относиться записи, у которых значения столбцов, входящих в группу, равны. Рассмотрим группировку по нескольким столбцам на примере следующего запроса:

```sql
SELECT name, number_plate, violation, count(*)
FROM fine
GROUP BY name, number_plate, violation;
```

результат:![пример](/images/group.png)

пример Вывести фамилию, номер машины и нарушение только для тех водителей, которые на одной машине нарушили одно и то же правило два и более раз. При этом учитывать все нарушения, независимо от того оплачены они или нет. Информацию отсортировать в алфавитном порядке, сначала по фамилии водителя, потом по номеру машины и, наконец, по нарушению:

[**_НАЗАД_**](#T-1)</a>

<br><a name="T23"></a>

```sql
select name, number_plate, violation
from fine
group by name, number_plate, violation
having count(*) > 1
```

пример В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей:

```sql
UPDATE  fine, (Select name, number_plate, violation
            FROM fine
            GROUP BY name, number_plate, violation
            HAVING COUNT(name)>1) query_in
SET sum_fine = sum_fine * 2
WHERE fine.name = query_in.name and
      fine.number_plate = query_in.number_plate and
      fine.violation = query_in.violation  and
      date_payment IS Null;

SELECT name, number_plate, violation, sum_fine, date_violation, date_payment
FROM fine;
```

[**_НАЗАД_**](#T-1)</a>

пример в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment;
уменьшить начисленный штраф в таблице fine в два раза (только для тех штрафов, информация о которых занесена в таблицу payment) , если оплата произведена не позднее 20 дней со дня нарушения:

```sql
UPDATE
    fine, payment
SET
    fine.date_payment = payment.date_payment,
    fine.sum_fine = if (datediff(payment.date_payment, payment.date_violation) < 21,
                       round(fine.sum_fine / 2, 2),
                        fine.sum_fine
                       )
WHERE
    fine.date_payment is null and
    fine.name = payment.name and
    fine.number_plate = payment.number_plate and
    fine.violation = payment.violation ;
```

пример Удалить из таблицы fine информацию о нарушениях, совершенных раньше 1 февраля 2020 года:

```sql
delete from fine
where '2020-02-01' > date_violation
```

[**_НАЗАД_**](#T-1)</a>
