# И.П. Карпова

# БАЗЫ ДАННЫХ

# Курс лекций и материалы для практических занятий

## Глава 1. Основные сведения

Описание данных называют метаданными. Метаданные хранятся в части
базы данных, которая называется каталогом или словарём-справочником
данных (ССД). Зная формат метаданных, можно запрашивать и изменять дан-
ные без написания дополнительных программ.

### 1.1. Информация, данные, знания. Терминология

**Система управления базами данных (СУБД)** – это совокупность программ и
языковых средств, предназначенных для управления данными в базе дан-
ных, ведения базы данных и обеспечения взаимодействия её с приклад-
ными программами.

### 1.2. Автоматизированная информационная система

Под **автоматизированной информационной системой (АИС)** будем понимать совокупность программно-аппаратных средств, предназначенных для
автоматизации деятельности, связанной с хранением, передачей и обработкой
информации.

По сферам применения и правилам организации различают два основных класса АИС, основанных на базе данных:

- **информационно-поисковые (ИПС)** (ориентированы, как правило, на извлечение подмножества хранимых данных, удовлетворяющих некоторому поисковому критерию)

- **системы обработки данных (СОД)** (Обращения пользователя к СОД чаще всего приводят к обновлению данных. Вывод данных может вовсе отсутствовать или представлять собой результат программной обработки хранимых сведений)

В зависимости от характера информационных ресурсов, с которыми
имеют дело АИС, их подразделяют на:

- документальные (объект хранения – документ, который содержит информацию, относящуюся к определённой предметной области.)

- фактографические (хранят сведения об объектах предметной области, их свойствах и взаимосвязях. Сведения о каждом объекте могут поступать в систему из множества различных источников. Кроме поиска и модификации данных, фактографические системы поддерживают статистические функции (нахождение суммы, минимума, максимума и т.п.). Фактографические АИС обычно принадлежат к классу систем обработки данных)

### 1.3. Предметная область информационной системы

Предметная область (ПрО) информационной системы рассматривается как совокупность реальных процессов и объектов (сущностей).

Данные предметной области представляются экземплярами сущностей (студент Иванов, преподаватель Сидоров, дисциплина "Базы данных"). Экзем пляры сущностей одного типа обладают одинаковыми наборами атрибутов, но должны отличаться значением хотя бы одного атрибута для того, чтобы быть узнаваемыми (например, студенты могут иметь одинаковые ФИО, но должны иметь разные номера зачётных книжек).

Среди атрибутов сущности можно выделить существенные и малозначительные. Признание какого-либо свойства существенным носит относительный характер. Например, атрибут Должность для сотрудника является существен- ным, а для читателя библиотеки – малозначительным.

Атрибуты можно условно классифицировать следующим образом:

1. Идентифицирующие и описательные атрибуты. Идентифицирующие атрибуты имеют уникальное значение для сущностей данного типа, описательные заключают в себе интересующие свойства сущности.
2. Составные и простые атрибуты. Простой атрибут состоит из одного компонента, его значение неделимо; составной атрибут является комбинациейнескольких компонентов, возможно, принадлежащих разным типам данных.
3. Однозначные и многозначные атрибуты (могут иметь соответственно одно или много значений для каждого экземпляра сущности).
4. Основные и производные атрибуты. Значение основного атрибута не зависит от других атрибутов. Значение производного атрибута вычисляется на основе значений других атрибутов.
5. Обязательные и необязательные. Значение обязательного атрибута всегда устанавливается при помещении данных в БД; значение необязательного атрибута может быть пропущено.

**связи**

- пациент–койка (1:1) – каждый пациент занимает одну койку, каждая койка в каждый момент времени может быть занята только одним пациентом;
- палата–пациент (1:n) – каждый пациент находится в одной палате, в каждой палате могут находиться несколько пациентов;
- пациент–врач (n:m) – каждый пациент может лечиться у нескольких врачей, каждый врач может лечить несколько пациентов.
- Обратите внимание: необязательная связь имеет модификатор "может", а у обязательной связи его нет.

**типы связи**

- унарная связь
- бинарная связь
- тернарная связь

### 1.5. Уровни представления данных

Современная технология баз данных основана на концепции многоуровневой архитектуры СУБД.

- **Концептуальный уровень** архитектуры ANSI/SPARC служит для поддержки единого взгляда на базу данных, общего для всех её приложений и независимого от них и от среды хранения.
- **Внутренний уровень** архитектуры поддерживает представление данных в среде хранения и пути доступа к ним.
- **Внешний уровень** архитектуры БД предназначен для групп пользователей. Описание представления данных для группы пользователей называется внешней схемой. Наличие внешнего уровня позволяет поддерживать разное представление одних и тех же данных для различных групп пользователей или задач.

На переходе "внешний – концептуальный" обеспечивается логическая независимость данных, на переходе "концептуальный – внутренний" -физическая независимость. Под **логической независимостью** подразумевается возможность вносить изменения в концептуальный уровень, не меняя представление БД для пользователей, или изменять представление данных для пользователей без изменения концептуальной схемы. **Физическая независимость** данных подразумевает возможность вносить изменения в схему хранения, не меняя концептуальную схему БД.

## **_ЗАДАЧИ_**

```
Задания для практических занятий
Тема: предметная область информационной системы
1. Выделить базовые и зависимые сущности для различных ПрО
("Отдел кадров", "Магазин", "Институт", "Проектная организа-
ция").
2. Определить набор атрибутов для различных сущностей ("Студент",
"Сотрудник", "Проект").
3. Определить связи между сущностями в различных ПрО ("Отдел
кадров", "Магазин", "Институт", "Проектная организация").
```

## Глава 2. ОСНОВНЫЕ МОДЕЛИ ДАННЫХ

Итак, модель данных состоит из трёх частей:

- Набор типов структур данных.
- Набор операторов или правил вывода, чтобы находить, выводить или преобразовывать информацию, содержащуюся в любых частях этих структур в любых комбинациях.
- Набор общих правил целостности, которые прямо или косвенно опреде-
  ляют множество непротиворечивых состояний базы данных и/или мно-
  жество изменений её состояния.

#### 2.1.1. Типы структур данных

Структуризация данных базируется на использовании концепций "агре-
гации" и "обобщения". Один из первых вариантов структуризации данных был
предложен Ассоциацией по языкам обработки данных:

Элемент данных => Агрегат данных => Запись => Набор => База данных

**Элемент** данных – наименьшая поименованная единица данных, к которой СУБД может обращаться непосредственно и с помощью которой выполняется построение всех остальных структур. Для каждого элемента данных должен быть определён его тип.
**Агрегат данных** – поименованная совокупность элементов данных внутри записи, которую можно рассматривать как единое целое. Агрегат может быть простым (включающим только элементы данных) и составным (включающим наряду с элементами данных и другие агрегаты).

**Запись** – поименованная совокупность элементов данных или элементов данных и агрегатов. Запись – это агрегат, не входящий в состав никакого друго- го агрегата; она может иметь сложную иерархическую структуру, поскольку допускается многократное применение агрегации. Различают тип записи (её структуру) и экземпляр записи, т.е. запись с конкретными значениями элементов данных. Одна запись описывает свойства одной сущности ПрО (экземпляра). Иногда термин "запись" заменяют термином "группа".

Среди элементов данных (полей записи) выделяются одно или несколько ключевых полей. Значения ключевых полей позволяют классифицировать сущность, к которой относится конкретная запись. Ключи с уникальными значениями называются **потенциальными**. Каждый ключ может представлять собой агрегат данных. Один из ключей назначается первичным, остальные являются вторичными. **Первичный** ключ идентифицирует экземпляр записи, его значение должно быть уникальным и обязательным для записей одного типа.

**База данных** – поименованная совокупность экземпляров групп и групповых отношений. Это самый высокий уровень структуризации данных.

#### 2.1.2. Операции над данными

Любая операция над данными включает в себя **селекцию данных (select)**, то есть выделение из всей совокупности именно тех данных, над которыми должна быть выполнена требуемая операция, и действие над выбранными данными, которое определяет характер операции.
По типу производимых действий различают следующие операции:

- идентификация данных и нахождение их позиции в БД;
- выборка (чтение) данных из БД;
- включение (запись) данных в БД;
- удаление данных из БД;
- модификация (изменение) данных БД.

Обработка данных в БД осуществляется с помощью процедур базы данных – **транзакций**. Транзакцией называют упорядоченное множество операций, переводящих БД из одного согласованного состояния в другое. Транзакция либо выполняется полностью, либо не выполняется совсем, если в процессе её выполнения возникает ошибка.

#### 2.1.3. Ограничения целостности

**Ограничения целостности** – это правила, которым должны удовлетворять значения элементов данных. Ограничения целостности делятся на явные и неявные.

- **Неявные** ограничения определяются самой структурой данных. Например, тот факт, что запись типа СОТРУДНИК имеет поле Дата рождения, служит, по существу, ограничением целостности, означающим, что каждый сотрудник организации имеет дату рождения, причём только одну.

- В качестве **явных** ограничений чаще всего выступают условия, накладываемые на значения данных. Например, номер паспорта является уникальным, заработная плата не может быть отрицательной.

### 2.2. Сетевая модель данных (СМД)

Сетевая модель позволяет организовывать БД, структура которых представляется графом общего вида. Каждая вершина графа хранит экземпляры сущностей (записи одного типа) и сведения о групповых отношениях с сущностями других типов. Для каждого типа записи выделяется первичный ключ – атрибут, значение которого позволяет однозначно идентифицировать запись среди экземпляров записей данного типа.

Связи между записями в СМД выполняются в виде указателей, т.е. каждая запись хранит ссылку на другую однотипную запись.

В СМД применяются следующие операции над данными:

- запомнить: внесение информации в БД;
- включить в групповое отношение: установление связей между данными;
- переключить: переход члена набора к другому владельцу;
- обновить: модификация данных;
- извлечь: чтение данных;
- удалить: физическое или логическое удаление данных;
- исключить из группового отношения: разрыв связей между данными.

### 2.3. Иерархическая модель данных (ИМД)

Иерархическая модель позволяет строить БД с иерархической древовидной структурой.

### 2.4. Реляционная модель данных (РМД)

#### 2.4.1. Понятие отношения

Базовой структурой РМД является отношение, основанное на декартовом произведении доменов. **Домен** – это множество значений, которое может принимать элемент данных (например, множество целых чисел, множество дат,
множество комбинаций символов длиной N и т.п.). Домен может задаваться перечислением элементов, указанием диапазона значений, функцией и т.д.

```
Пример. Для доменов D1 = (1, 2), D2 = (A, B, C) декартово произведение
D = D1xD2 будет таким:
D = {(1,A), (1,B), (1,C), (2,A), (2,B), (2,C)}.

```

Подмножество декартова произведения доменов называется **отношением**.
Элементы отношения называют **кортежами** (или записями). Каждый кортеж отношения соответствует одному экземпляру сущности определённого типа. Элементы кортежа принято называть **атрибутами** (или полями).
y

#### 2.4.2. Свойства отношений

Отношение обладает двумя основными свойствами:

- В отношении не должно быть одинаковых кортежей, т.к. это множество.
- Порядок кортежей в отношении несущественен.

Отношение удобно представлять как таблицу, где строка является кортежем, а столбец соответствует домену. Количество строк в таблице (кортежей в отношении) называется **мощностью отношения**, количество столбцов (атрибутов) – **арностью**.

**Ключ отношения** – это атрибут (группа атрибутов), значения которого классифицируют или идентифицируют кортеж. Например, значение атрибута Группа отношения СТУДЕНТЫ позволяет выделить среди всех студентов ин- ститута студентов конкретной группы. Если ключ состоит из нескольких атрибутов, он называется составным. Если значения ключа уникальны в рамках столбца отношения, то такой ключ называется потенциальным. Потенциальных ключей может быть несколько (или не быть ни одного), но для отношения выделяется один основной ключ – первичный. **Первичный ключ** идентифицирует экземпляр сущности, его значение должно быть уникальным (unique) и обязательным (not null).

РМД не поддерживает групповые отношения (по версии CODASYL). Для связей между отношениями используются внешние ключи. **Внешний ключ (foreign key)** – это атрибут подчинённого (дочернего) отношения, который является копией **первичного (primary key)** или **уникального (unique)** ключа родительского отношения. (Пример – отношение ОЦЕНКИ, связанное с отношением СТУДЕНТЫ внешним ключом Номер зачётной книжки)

**Внешний ключ** – это ограничение целостности, в соответствии с которым множество значений внешнего ключа является подмножеством значений первичного или уникального ключа родительской таблицы.

**Ограничение целостности по внешнему ключу** проверяется в двух случаях:

- при добавлении записи в подчинённую таблицу СУБД проверяет, что в ро-
  дительской таблице есть запись с таким же значением первичного ключа;
- при удалении записи из родительской таблицы СУБД проверяет, что в под-
  чинённой таблице нет записей с таким же значением внешнего ключа.

В РМД используются следующие операции:

- запомнить: внесение информации в БД (требует формирования значений уникального ключа и обязательных атрибутов кортежа);
- извлечь: чтение данных;
- обновить: модификация данных – изменение значений атрибутов кортежей;
- удалить: физическое или логическое удаление данных (кортежей).

### 2.5. Объектно-реляционная модель данных

### 2.6. Объектно-ориентированная модель данных

## **_ЗАДАЧИ_**

```
Задания для практических занятий
Тема: составление реляционных отношений
1. Составить реляционные отношения для различных ПрО ("Отдел
кадров": список должностей, список сотрудников, список под-
разделений; "Магазин": список товаров, список поставщиков,
список поставок; "Проектная организация": список отделов,
список сотрудников, список проектов).
2. Определить первичные ключи для созданных отношений.
3. Определить внешние ключи для созданных отношений.
```

## Глава 3. ВВЕДЕНИЕ В ЯЗЫК SQL

#### 3.1.1. Основные операции реляционной алгебры

1. **Проекция (project)**.
   Это унарная операция (выполняемая над одним отношением), служащая для выбора подмножества атрибутов из отношения R. Она уменьшает арность отношения и может уменьшить мощность отношения за счёт исключения одинаковых кортежей.

2. **Селекция (select)**.
   Это унарная операция, результатом которой является подмножество кортежей исходного отношения, соответствующих условиям, которые накладываются на значения определённых атрибутов. Это одна из наиболее часто используемых операций SQL.

3. **Декартово произведение (сartesian product)**.
   Это бинарная операция над разносхемными отношениями, соответствующая определению декартова произведения для РМД.

4. **Объединение (union)**.
   Объединением двух односхемных отношений R и S называется отношение T = R U S, которое включает в себя все кортежи обоих отношений без повторов.

5. **Разность (except)**.
   Разностью односхемных отношений R и S называется множество кортежей R, не входящих в S.

#### 3.1.2. Вспомогательные операции реляционной алгебры

6. **Пересечение (intersect)**.
   Пересечение двух односхемных отношений R и S есть подмножество корте-
   жей, принадлежащих обоим отношениям.

7. **Соединение (join)**.
   Эта операция определяет подмножество декартова произведения двух разносхемных отношений. Кортеж декартова произведения входит в результирующее отношение, если для атрибутов разных исходных отношений выполняется некоторое условие соединения F.

### 3.2. Общие сведения о языке SQL

Язык работы с базами данных должен предоставлять пользователям следующие возможности:

- создавать базу данных и таблицы с полным описанием их структуры;
- выполнять основные операции манипулирования данными (добавление, изменение, удаление данных);
- выполнять запросы, осуществляющие преобразование данных в необходимую информацию.

Создание базы данных обычно выполняется автоматически при установке самой СУБД, поэтому в данном пособии не рассматривается.

В командах SQL не различаются прописные и строчные буквы (за исключением строчных литералов). Символы и строки символов заключаются в одинарные кавычки, например, 'N', 'учебник'. Однострочные комментарии начинаются с двух минусов (--), многострочные заключаются в символы /_ и _/. Каждая команда заканчивается символом ';'.

### 3.3. Создание таблиц

##### **_Синтаксис команд и примеры, приведённые в данном пособии, соответствуют синтаксису СУБД Oracle 9i и выше. _**

Стандарт SQL включает понятие неопределённого или неизвестного значения – NULL-значения. Для обязательных полей устанавливается ограничение NOT NULL.

Для любого поля с помощью конструкции **DEFAULT** <выражение> мо- жет быть задано значение по умолчанию. Оно используется в тех случаях, когда при добавлении данных в таблицу значение этого поля не указывается.

Для ограничений целостности можно задавать имена: **CONSTRAINT** <имя> <ограничение целостности>

### 3.4. Команды модификации данных

К командам модификации данных (DML) относятся добавление, удаление и изменение (обновление) записи (строки таблицы).

**INSERT** – добавление записи в таблицу. Синтаксис команды:

```sql
INSERT INTO <имя таблицы> [(<имя поля>.,..)]
VALUES (<список выражений>) | <запрос>;
```

### 3.5. Извлечение данных из таблиц

**DISTINCT** – предикат удаления из результирующей таблицы повторов строк.
**ALL** – предикат, обратный к DISTINCT. Это значение используется по умолчанию, его можно не указывать.

Рассмотрим основные предложения (фразы) команды SELECT:
**SELECT** – после этого ключевого слова указывается список выбора – список выражений, которые будут образовывать результирующую таблицу. Выражению можно сопоставить временный синоним (алиас), который будет названием поля результирующей таблицы, например: (sal*0.87+bonus) AS salary Если надо вывести все поля из тех таблиц, к которым обращается данный запрос, можно указать символ *. В этом случае сначала будут выведены поля таблицы, стоящей первой в предложении **FROM**, затем – второй и т.д. Поля, относящиеся к одной таблице, будут выводиться в том порядке, в каком они были указаны при создании таблицы.
**FROM** – в этой части указывается имя таблицы (имена таблиц), из которой будут извлекаться данные.
**WHERE** – эта часть содержит условия выбора отдельных записей.
**GROUP BY** – объединяет в одну группу все записи с одинаковым значением указанного поля (комбинации полей). Каждой такой группе в результирующей таблице соответствует одна запись.
**HAVING** – позволяет указать условия выбора для групп записей.
**ORDER BY** – упорядочивает результирующие строки по значению одного или нескольких полей: ASC – по возрастанию, DESC – по убыванию.

**_Порядок выполнения операции SELECT такой:_**

1. Выбор из указанной во фразе FROM таблицы тех записей, которые удовлетворяют условию отбора (WHERE).
2. Группировка полученных записей (GROUP BY).
3. Выбор тех групп, которые удовлетворяют условию отбора групп (HAVING).
4. Сортировка записей в указанном порядке (ORDER BY).
5. Извлечение из записей полей, заданных в списке выбора, и формирование результирующей таблицы.

Если во фразе FROM указаны две и более таблицы, то эта последовательность
действий выполняется для декартова произведения указанных таблиц.

#### 3.5.2. Операторы и предикаты

Расширение возможностей команд языка SQL достигается за счёт применения различных операторов, предикатов и функций.
Операторы:

- символьные: || – конкатенация строк;
- арифметические: +, –, \*, /;– 44 –
- сравнения: =, >, <, >=, <=, <>;
- логические: AND, OR, NOT.

**_Предикаты, используемые в командах:_**

Предикаты, используемые в командах:

- **IN** – предикат вхождения в список:
  <выражение> IN (<список значений>) определяет множество значений, с которыми будет сравниваться значение <выражения>. Предикат считается истинным, если значение выра жения равно хотя бы одному из элементов множества.
- **BETWEEN** – предикат нахождения в диапазоне:
  <выражение> BETWEEN <значение1> AND <значение2> определяет, входит ли значение <выражения> в указанные границы. Если значение выражения меньше, чем <значение1>, или больше, чем <значение2>, предикат возвращает "ложь".
- **LIKE** – предикат подобия:
  <выражение> LIKE 'образец' используется для сравнения строк, применяется только к полям типа CHAR, VARCHAR. Возможно использование шаблонов: '\_' – один любой символ и '%' – произвольное количество символов (в т.ч., ни одного);
- **IS NULL** – предикат неопределённого значения:– 45 –
  <выражение> IS NULL определяет, установлено ли значение поля; возвращает истину, если не установлено. Другие предикаты и операторы сравнения возвращают не определённый результат (NULL), если хотя бы один из операндов имеет значение NULL. Значение NULL интерпретируется как "ложь".

Все эти предикаты могут комбинироваться с операцией "не": NOT IN,
NOT LIKE, NOT BETWEEN, IS NOT NULL.

##### \***\* примеры на стр 45\*\***

Для лучшего понимания работы с базой данных рассмотрим в несколько упрощённом виде, как СУБД выполняет предыдущую команду SELECT:
I. Фаза разбора.

1. По первому ключевому слову определяется тип команды (выборка данных). Разбор команды начинается с части FROM.
2. По словарю-справочнику данных (ССД) система проверяет, что есть такая таблица emp, а в ней есть поля tabno, name, born, post.
3. Команда проверяется на синтаксическую правильность: если есть ошибки, пользователю выдаётся сообщение об ошибке.
4. Далее система проверяет права пользователя, который запустил эту команду (также с помощью информации из ССД): если права на чтение данных из указанной таблицы есть, то система приступает к выполнению операции; иначе – выдаёт сообщение о недостаточности прав.
   II. Фаза выполнения.
5. Из ССД извлекается адрес, по которому расположены данные указанной таблицы.
6. Система начинает по одной строке считывать данные таблицы из памяти. Для каждой строки проверяется выполнение условия: если условие выполняется, то строка помещается в курсор, иначе – пропускается.
7. После считывания всех строк содержимое курсора упорядочивается, из строк в курсоре извлекаются те поля, которые участвуют в списке выбора, и выводятся на экран в виде таблицы (если пользователь работает в интерактивном режиме).

#### 3.5.3. Функции агрегирования

Для подсчёта различных агрегированных значений (по группе записей)
стандарт SQL включает т.н. функции агрегирования:

- COUNT(\*) – определяет количество строк (записей) в результате.
- MAX(<поле>), MIN(<поле>) – определяет максимальное (минимальное)
  значение указанного поля в результирующем множестве.
- SUM(<поле>) – определяет арифметическую сумму значений указанного
  числового поля в результирующем множестве записей.
- AVG(<поле>) – определяет среднее арифметическое значений указанного
  числового поля в результирующем множестве записей.

Правила уточнения использования агрегирующих функций:

- COUNT (<поле>) – подсчёт количества ненулевых значений поля;
- COUNT (distinct <поле>) – подсчёт количества разных значений поля;
- SUM (distinct <поле>) – суммирование разных значений поля;
- AVG (distinct <поле>) – среднее арифметическое разных значений поля

При использовании фразы GROUP BY существует правило, которого надо строго придерживаться: в списке выбора могут быть указаны только функцииагрегирования, константы и поля, перечисленные в GROUP BY.

Если включить в список выбора поля, не указанные в GROUP BY, то СУБД не будет выполнять такой запрос и выдаст ошибку "нарушение условия группирования" (not a GROUP BY expression).

Результатом запроса SELECT на нескольких таблицах будет декартово произведение исходных таблиц. Если в части WHERE при этом указать усло- вие соответствия значений полей разных таблиц, то получится соединение таблиц. Для полей с одинаковыми именами необходимо указывать имя таблицы (или алиас) перед именем поля, разделяя их точкой (т.н. квалифицированная ссылка).

Кроме внутреннего соединения (INNER JOIN) существует ещё внешнее соединение (OUTER JOIN). Продемонстрируем его на примере.

Различают 3 типа внешнего (открытого) соединения:

- . LEFT JOIN – левое открытое соединение таблиц R и S, при котором в результат входят все строки левой таблицы R и те строки правой таблицы S, которые удовлетворяют условию соединения таблиц;
- . RIGHT JOIN – правое открытое соединение таблиц R и S, при котором в результат входят все строки правой таблицы S и те строки левой таблицы R, которые удовлетворяют условию соединения таблиц;
- . FULL JOIN – полное открытое соединение таблиц R и S,

#### 3.5.5. Подзапросы

Подзапросом называется запрос SELECT, который находится внутри другой команды SQL. Подзапросы можно разделить на следующие группы в зависимости от возвращаемых результатов:

- Скалярные – это подзапросы, возвращающие единственное значение.
- Векторные – подзапросы, возвращающие от 0 до нескольких однотипных элементов (список элементов).
- Табличные – это подзапросы, возвращающие таблицу.

Подзапросы бывают коррелированные и некоррелированные. Коррелированные подзапросы содержат ссылки на значения полей в запросе верхнего уровня, а некоррелированные – не содержат. Некоррелированный подзапрос вычисляется один раз для запроса верхнего уровня, а коррелированный – для каждой строки запроса верхнего уровня.

Сначала рассмотрим использование подзапросов в команде SELECT.
Подзапросы могут располагаться в разных частях этой команды:

- в части FROM – табличные некоррелированные;
- в части WHERE – любые;
- в части HAVING – любые;
- в части SELECT – скалярные.

Подзапрос всегда стоит справа от оператора сравнения или предиката.
Следующие операторы используются для модификации операторов сравнения:

- ALL – оператор, эквивалентный понятию "все". Например:
  > ALL (< ALL) – больше (меньше) каждого значения элементов результиру-\ ющего множества.
- ANY (SOME) – оператор, эквивалентный понятию "любой".
  = ANY – равно одному из значений элементов результирующего множества (эквивалентно использованию предиката IN).
  > ANY (< ANY) – больше (меньше) любого значения элементов результиру- ющего множества.
- EXISTS – оператор, эквивалентный понятию "существует". Может использоваться с логическим оператором NOT.

#### 3.5.6. Самосоединение

#### 3.5.7. Замечания по использованию NULL-значений

#### 3.5.8. Оператор CASE

### 3.6. Удаление объектов базы данных
